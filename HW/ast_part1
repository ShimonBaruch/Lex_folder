%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "node.h" // כלול את הקובץ header שמכיל את הגדרת Node

void yyerror(const char *s);
int yylex(void);

Node *ast_root = NULL;
%}

%union {
    int ival;
    float fval;
    double dval;
    char cval;
    char *sval;
    int bval;
    Node *node;
}%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include "lex.yy.c"
	typedef struct node
	{
		char *token;
		struct node *left;
		struct node *right;
	} node;
	node* mknode(char* token, node *left, node *right);
	void Printtree(node *tree);
	void printTabs(int n);
	int yylex();
	int yyerror(char *e);
	
	int printlevel=0;
%}
%union
{
    struct node *node;
    char *string;
}



%token <string> COMMENT WHILE IF ELSE FOR 
%token <string> RETURN
%token <string> BOOL STRING CHARPTR CHAR INT INTPTR PROCEDUR
%token <string> AND ADDRESS EQL ASSINGMENT OR LENGTH GREATEREQL GREATER LESSEQL LESS NOTEQL NOT
%token <string> DIVISION PLUS MINUS MULTI VARIABLE
%token <string> STRING_LTL REAL_LTL CHAR_LTL NULLL
%token <string> MAIN IDENTIFIER SEMICOLON COMMA OPENPAREN CLOSEPAREN OPENBRACKET CLOSEBRACKET OPENBRACE CLOSEBRACE
%token <string> DECIMAL_LTL HEX_LTL BOOLTRUE BOOLFALSE  REAL REALPTR FUNCTION COLON  DEREFRENCE 

%left PLUS MINUS RETURN
%left MULTI DIVISION
%left EQL NOTEQL LESS LESSEQL GREATEREQL GREATER OR AND
%left SEMICOLON 
%right NOT CLOSEBRACE

%nonassoc IDENTIFIER 
%nonassoc OPENPAREN
%nonassoc IF
%nonassoc ELSE 


%type <node> address_expr address_exprs stmnts stmnt_block derefrence_expr  expr_list call_func 
%type <node> expr lhs assmnt_stmnt new_block 
%type <node> stmnt type_pro type_id var_id declear paren_expr
%type <node> pro_body para_list para_pro procedure procedures
%type <node> main program project declears RET
%%
 //Main project
project: cmmnt program { Printtree($2); printf("syntax valid\n");};

program: procedures main {$$=mknode("CODE",$1,$2);}

 //comments
cmmnt: COMMENT cmmnt| ;

 //this is the main
main: PROCEDUR MAIN OPENPAREN CLOSEPAREN OPENBRACE pro_body CLOSEBRACE
{
$$=mknode("proc",
mknode("Main",mknode("\n",NULL,NULL),NULL),
mknode("ARGS",NULL,$6));
}	| {$$=NULL;};

//functions
procedures: procedures  procedure {$$=mknode("",$1,$2);}
	| {$$=NULL;};

//function
procedure: FUNCTION IDENTIFIER OPENPAREN para_pro CLOSEPAREN cmmnt RETURN type_pro  OPENBRACE  pro_body RET CLOSEBRACE
{ 
		$$=mknode("func",mknode($2,mknode("\n",NULL,NULL),mknode("ARGS",$4,mknode("return",$8,NULL))),mknode("",$10,$11));	
}
| PROCEDUR IDENTIFIER OPENPAREN para_pro CLOSEPAREN  OPENBRACE  pro_body CLOSEBRACE
{
	$$=mknode("proc",mknode($2,mknode("\n",NULL,NULL),NULL),mknode("ARGS",$4,$7));
};


//list of parameter for function or not
para_pro: para_list {$$=$1;}
| {$$=NULL;};

//list of parameter

para_list: var_id COLON type_id {$$=mknode("(",$3,mknode("",$1,mknode(")",NULL,NULL)));}
	|  para_list SEMICOLON cmmnt  para_list 
	{$$=mknode("",$1,mknode("",$4,NULL));}	;

 //Procedure body
pro_body: cmmnt  procedures declears stmnts 
{
	$$=mknode("(BODY\n    ", mknode("",$2,NULL),mknode("",$3,mknode("",$4,mknode("}",NULL,NULL))));
};


//list of declears
declears: declears declear  {$$=mknode("",$1,$2);} | {$$=NULL;}  ;

//declaration of varibals/ 
declear: VARIABLE var_id COLON type_id cmmnt SEMICOLON cmmnt
{
	$$=mknode("var", $4,$2);
};

//list of id like a,b,c/
var_id: IDENTIFIER COMMA var_id {$$=mknode($1, mknode(" ", $3, NULL),NULL);}
	| IDENTIFIER {$$=mknode($1, NULL, NULL);} ;


//types without string/
type_id: BOOL {$$=mknode("boolean", NULL, NULL);}
	| STRING OPENBRACKET DECIMAL_LTL CLOSEBRACKET {$$=mknode("string", NULL, NULL);}
	| CHAR {$$=mknode("char", NULL, NULL);}
	| INT {$$=mknode("int", NULL, NULL);}
	| REAL {$$=mknode("real", NULL, NULL);}
	| INTPTR {$$=mknode("int*", NULL, NULL);}
	| CHARPTR {$$=mknode("char*", NULL, NULL);}
	| REALPTR {$$=mknode("real*", NULL, NULL);};



//type for returning from a function
type_pro: BOOL {$$=mknode("boolean", NULL, NULL);}
 	| STRING {$$=mknode("string", NULL, NULL);}
	| CHAR {$$=mknode("char", NULL, NULL);}
	| INT {$$=mknode("int", NULL, NULL);}
	| REAL {$$=mknode("real", NULL, NULL);}
	| INTPTR {$$=mknode("int*", NULL, NULL);}
	| CHARPTR {$$=mknode("char*", NULL, NULL);}
	| REALPTR {$$=mknode("real*", NULL, NULL);};
	

//Statments
stmnts: stmnts stmnt {$$=mknode("",$1,$2);} | {$$=NULL;};

//stmnt_block
stmnt_block: stmnt {$$=$1;}|RETURN expr SEMICOLON {$$=mknode("return",$2,NULL);};

//new block in stmnts
new_block: OPENBRACE cmmnt declears stmnts RET CLOSEBRACE cmmnt
{
	$$=mknode("{",$3,mknode("", $4, mknode("",$5,mknode("}",NULL,NULL))));
};


RET: RETURN expr SEMICOLON cmmnt {$$=mknode("return",$2,NULL);}| {$$=NULL;};

//Statment
stmnt: IF OPENPAREN expr CLOSEPAREN  stmnt_block 
{
	$$=mknode("if",
	mknode("(", $3, 
	mknode(")",NULL,NULL)),$5);
}%prec IF
| IF OPENPAREN expr CLOSEPAREN   stmnt_block    ELSE  stmnt_block  
{
	$$=mknode("if-else",
	mknode("(", $3, 
	mknode(")",NULL,NULL)),
	mknode("",$5,
	mknode("",$7,NULL)));
}
| WHILE cmmnt OPENPAREN expr CLOSEPAREN  stmnt_block  
{
	$$=mknode("while",
	mknode("(", $4, 
	mknode(")",NULL,NULL)),$6);
}
| FOR cmmnt OPENPAREN assmnt_stmnt SEMICOLON expr SEMICOLON assmnt_stmnt CLOSEPAREN stmnt_block 
{
		$$= mknode("for",
			mknode("(",
			mknode("",$4,$6),
			mknode("",$8,
			mknode(")",NULL,NULL))),$10);		
}
| assmnt_stmnt SEMICOLON cmmnt {$$=mknode("",$1,NULL);}
| expr SEMICOLON cmmnt {$$=$1;}
| new_block {$$=$1;};




//assiment statment
assmnt_stmnt: lhs ASSINGMENT expr 
{
	$$=mknode("=",$1,$3);
};


//lefd hand side id
lhs: IDENTIFIER OPENBRACKET expr CLOSEBRACKET 
{
	$$=mknode($1, mknode("[",$3,mknode("]",NULL,NULL)), NULL);
} 
| IDENTIFIER {$$=mknode($1,NULL,NULL);}
| derefrence_expr{$$=$1;} ;


	
//Expresion
expr:  OPENPAREN expr CLOSEPAREN {$$=mknode("(",$2,mknode(")",NULL,NULL));}|
//bool oper
    expr EQL expr {$$=mknode("==",$1,$3);}
	| expr NOTEQL expr {$$=mknode("!=",$1,$3);}
	| expr GREATEREQL expr {$$=mknode(">=",$1,$3);}
	| expr GREATER expr {$$=mknode(">",$1,$3);}
	| expr LESSEQL expr {$$=mknode("<=",$1,$3);}
	| expr LESS expr {$$=mknode("<",$1,$3);}
	| expr AND expr {$$=mknode("&&",$1,$3);}
	| expr OR expr {$$=mknode("||",$1,$3);}
//aritmetical operator
	| expr PLUS expr {$$=mknode("+",$1,$3);}
	| expr MINUS expr {$$=mknode("-",$1,$3);}
	| expr MULTI expr {$$=mknode("*",$1,$3);}
	| expr DIVISION expr {$$=mknode("/",$1,$3);}
//not operator
	| NOT expr {$$=mknode("!",$2,NULL);}
	| address_exprs {$$=$1;}
	| derefrence_expr {$$=$1;}
	| call_func cmmnt {$$=$1;}
	| DECIMAL_LTL {$$=mknode($1,NULL,NULL);}
	| HEX_LTL {$$=mknode($1,NULL,NULL);}
	| CHAR_LTL {$$=mknode($1,NULL,NULL);}
	| REAL_LTL {$$=mknode($1,NULL,NULL);}
	| STRING_LTL {$$=mknode($1,NULL,NULL);}
	| BOOLFALSE {$$=mknode($1,NULL,NULL);}
	| BOOLTRUE {$$=mknode($1,NULL,NULL);}
	| LENGTH IDENTIFIER LENGTH 
	{
		$$=mknode("|",
		mknode($2,NULL,NULL),
		mknode("|",NULL,NULL));
	}
	| IDENTIFIER OPENBRACKET expr CLOSEBRACKET 
	{$$=mknode($1,mknode("[",$3,mknode("]",NULL,NULL)),NULL);}
	| IDENTIFIER {$$=mknode($1,NULL,NULL);}
	| NULLL {$$=mknode("null",NULL,NULL);};

//address expression like &id

address_exprs:ADDRESS address_exprs {$$=mknode($1,$2,NULL);} | address_expr {$$=$1;};

address_expr: ADDRESS IDENTIFIER {$$=mknode("&",mknode($2,NULL,NULL),NULL);}
	| ADDRESS OPENPAREN IDENTIFIER CLOSEPAREN {$$=mknode("&",mknode("(",mknode($3,NULL,NULL),NULL),mknode(")",NULL,NULL));}
	| ADDRESS IDENTIFIER OPENBRACKET expr CLOSEBRACKET 
	{$$=mknode("&", mknode($2,NULL,NULL), mknode("[",$4,mknode("]",NULL,NULL)));}
	| ADDRESS OPENPAREN IDENTIFIER OPENBRACKET expr CLOSEBRACKET CLOSEPAREN 
	{
		$$=mknode("&",
		mknode("(", 
		mknode($3,NULL,NULL),
		mknode("[",$5,NULL)), 
		mknode("]",NULL,mknode(")",NULL,NULL)));
	};
//value expression like ^id


	derefrence_expr: DEREFRENCE IDENTIFIER {$$=mknode("^",mknode($2,NULL,NULL),NULL);}
	| DEREFRENCE OPENPAREN expr CLOSEPAREN {$$=mknode("^",mknode("(",$3,NULL),mknode(")",NULL,NULL));}
	| DEREFRENCE IDENTIFIER OPENBRACKET expr CLOSEBRACKET 
	{$$=mknode($1, mknode($2,NULL,NULL), mknode("[",$4,mknode("]",NULL,NULL)));};

	//list of expreession
expr_list: expr COMMA expr_list {$$=mknode("",$1,mknode(",",$3,NULL));} 
	| expr {$$=mknode("",$1,NULL);}
	| {$$=NULL;};

paren_expr:OPENPAREN expr_list CLOSEPAREN {$$=$2;};
//call func rul 
call_func: IDENTIFIER paren_expr {$$=mknode("Call func",mknode($1,NULL,NULL),mknode("ARGS",$2,NULL));} ;
%%



int main()
{
	return yyparse();	
}

/* allocation for node*/
node* mknode (char *token, node *left, node *right)
{
	node *newnode = (node*)malloc(sizeof(node));
	newnode->left=left;
	newnode->right=right;
	newnode->token=token;
	return newnode;
}

void printTabs(int n)
{
	int i;
	for(i=0;i<n/3;i++)
		printf(" ");
}
void Printtree(node* tree)
{
	int flag = 4;
	printTabs(printlevel); 
	if(strcmp(tree->token, "var") == 0)
	{
		
		printf("(DECLARE ");
		flag=2;
		
		
	}
	else if(strcmp(tree->token, "if") == 0)
	{
		printf("(IF\n");
		flag = 1;
		
		
	}
		else if(strcmp(tree->token, "while") == 0)
	{
		printf("(WHILE\n");
		flag = 1;
		
		
	}
			else if(strcmp(tree->token, "for") == 0)
	{
		printf("(FOR\n");
		flag = 1;
		
		
	}
		else if(strcmp(tree->token, "func") == 0 ||strcmp(tree->token, "proc") == 0 ||strcmp(tree->token, "CODE") == 0||strcmp(tree->token, "Call func") == 0)
	{
		printf("(%s \n",tree->token);
		flag= 2;
		
	}
		else if(strcmp(tree->token, "ARGS") == 0)
	{
		printf("(ARGS ");
		if(tree->left)
		{
			flag = 2;
			printf("\n");
			
		}
		else{
			printf(" NONE)\n"); 
		}
	

	}
		else if(strcmp(tree->token, "if-else") == 0)
	{
		printf("(IF-ELSE\n");
		printlevel--;
		
		flag = 1;
	}
			else if(strcmp(tree->token, "return") == 0)
	{
		printf("(RET ");
		flag = 2;
	}
	else if(strcmp(tree->token, "{") == 0)
	{
                printf("(BLOCK\n");
				
				
	}
	else if(strcmp(tree->token, "}") == 0)
	{
		printf(")\n");
	}
	else if(strcmp(tree->token, "") == 0);
	else if(strcmp(tree->token, "(") == 0)
			printf("(");
	else if(strcmp(tree->token, "\n") == 0)
			printf("\n");
	else if(strcmp(tree->token, ")") == 0)
			printf(")\n");
	else if(strcmp(tree->token, ",") == 0)
			printf(",");
	else if(strcmp(tree->token, ";") == 0)
			printf("\n");
	else if(strcmp(tree->token, "&&") == 0 ||
strcmp(tree->token, "/") == 0 || 
strcmp(tree->token, "=") == 0 || 
strcmp(tree->token, "==") == 0 || 
strcmp(tree->token, ">") == 0 || 
strcmp(tree->token, ">=") == 0 || 
strcmp(tree->token, "<") == 0 || 
strcmp(tree->token, "<=") == 0 || 
strcmp(tree->token, "-") == 0 || 
strcmp(tree->token, "!") == 0 || 
strcmp(tree->token, "!=") == 0 || 
strcmp(tree->token, "||") == 0 || 
strcmp(tree->token, "+") == 0 || 
strcmp(tree->token, "*") == 0 || 
strcmp(tree->token, "&") == 0 || 
strcmp(tree->token, "^") == 0 || 
strcmp(tree->token, "|") == 0 || 
strcmp(tree->token, ",") == 0 )
	{
			printf("(%s",tree->token);
			flag=1;
			if(strcmp(tree->token, "=") == 0)
				flag=2;
				
	}
	else
	{
		if(tree && (!tree->left && !tree->right)
		||strcmp(tree->token, "Main") == 0)
		{
			printf("%s ", tree->token);
			
		}
		else
		{
			printlevel++;
			printf("%s", tree->token);
			printlevel--;
		
		}
	}
	if (tree->left) 
	{
		printlevel++;
		Printtree(tree->left);
		printlevel--;
	}
	
	if (tree->right)
	{
		printlevel++;
		Printtree(tree->right);
		printlevel--;
		
	}
	if(flag == 2)
		printf(")\n");
	
	if(flag == 1)
		printf(")");
	if(flag == 0)
		printf("\n)");
}
int yyerror(char *e)
{
	int yydebug=1; 
	fflush(stdout);
	fprintf(stderr,"Error %s at line %d\n" ,e,yylineno);
	fprintf(stderr, "does not accept '%s'\n",yytext);
	
	return 0;
}
%token <cval> CHAR_LITERAL
%token <ival> INT_LITERAL
%token <dval> DOUBLE_LITERAL
%token <fval> FLOAT_LITERAL
%token <sval> STRING_LITERAL IDENTIFIER
%token SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET

%type <node> program function_list function type parameter_list parameter_declaration_list parameter_declaration body declaration_list declaration statement_list statement assignment if_statement while_statement for_statement do_while_statement return_statement expression term factor function_call argument_list argument_declaration_list identifier_list

%%

program:
    function_list
    {
        ast_root = $1;
    }
    ;

function_list:
    function
    | function_list function
    {
        $$ = create_node("FUNCTION_LIST", $1, NULL, $2, NULL);
    }
    ;

function:
    PUBLIC type IDENTIFIER LPAREN parameter_list RPAREN STATIC LBRACE body RBRACE
    {
        $$ = create_node("FUNCTION", $2, $5, NULL, $3);
    }
    | PRIVATE type IDENTIFIER LPAREN parameter_list RPAREN STATIC LBRACE body RBRACE
    {
        $$ = create_node("FUNCTION", $2, $5, NULL, $3);
    }
    | PUBLIC type IDENTIFIER LPAREN parameter_list RPAREN LBRACE body RBRACE
    {
        $$ = create_node("FUNCTION", $2, $5, NULL, $3);
    }
    | PRIVATE type IDENTIFIER LPAREN parameter_list RPAREN LBRACE body RBRACE
    {
        $$ = create_node("FUNCTION", $2, $5, NULL, $3);
    }
    ;

type:
    BOOL { $$ = create_node("TYPE", NULL, NULL, NULL, "BOOL"); }
    | CHAR { $$ = create_node("TYPE", NULL, NULL, NULL, "CHAR"); }
    | INT { $$ = create_node("TYPE", NULL, NULL, NULL, "INT"); }
    | DOUBLE { $$ = create_node("TYPE", NULL, NULL, NULL, "DOUBLE"); }
    | FLOAT { $$ = create_node("TYPE", NULL, NULL, NULL, "FLOAT"); }
    | STRING { $$ = create_node("TYPE", NULL, NULL, NULL, "STRING"); }
    | INT_PTR { $$ = create_node("TYPE", NULL, NULL, NULL, "INT_PTR"); }
    | CHAR_PTR { $$ = create_node("TYPE", NULL, NULL, NULL, "CHAR_PTR"); }
    | DOUBLE_PTR { $$ = create_node("TYPE", NULL, NULL, NULL, "DOUBLE_PTR"); }
    | FLOAT_PTR { $$ = create_node("TYPE", NULL, NULL, NULL, "FLOAT_PTR"); }
    | VOID { $$ = create_node("TYPE", NULL, NULL, NULL, "VOID"); }
    ;

parameter_list:
    /* empty */
    {
        $$ = NULL;
    }
    | parameter_declaration_list
    {
        $$ = $1;
    }
    ;

parameter_declaration_list:
    parameter_declaration
    {
        $$ = $1;
    }
    | parameter_declaration_list COMMA parameter_declaration
    {
        $$ = create_node("PARAM_LIST", $1, NULL, $3, NULL);
    }
    ;

parameter_declaration:
    type IDENTIFIER
    {
        $$ = create_node("PARAM", $1, NULL, NULL, $2);
    }
    ;

body:
    declaration_list statement_list
    {
        $$ = create_node("BODY", $1, NULL, $2, NULL);
    }
    ;

declaration_list:
    /* empty */
    {
        $$ = NULL;
    }
    | declaration_list declaration
    {
        $$ = create_node("DECL_LIST", $1, NULL, $2, NULL);
    }
    ;

declaration:
    VAR type IDENTIFIER SEMICOLON
    {
        $$ = create_node("DECL", $2, NULL, NULL, $3);
    }
    | VAR type IDENTIFIER ASSIGN expression SEMICOLON
    {
        $$ = create_node("DECL_ASSIGN", $2, $5, NULL, $3);
    }
    | VAR type identifier_list SEMICOLON
    {
        $$ = create_node("DECL_LIST", $2, NULL, $3, NULL);
    }
    | VAR type identifier_list ASSIGN expression SEMICOLON
    {
        $$ = create_node("DECL_LIST_ASSIGN", $2, $5, $3, NULL);
    }
    ;

identifier_list:
    IDENTIFIER
    {
        $$ = create_node("ID_LIST", NULL, NULL, NULL, $1);
    }
    | identifier_list COMMA IDENTIFIER
    {
        $$ = create_node("ID_LIST", $1, NULL, NULL, $3);
    }
    ;

statement_list:
    /* empty */
    {
        $$ = NULL;
    }
    | statement_list statement
    {
        $$ = create_node("STMT_LIST", $1, NULL, $2, NULL);
    }
    ;

statement:
    assignment
    {
        $$ = $1;
    }
    | if_statement
    {
        $$ = $1;
    }
    | while_statement
    {
        $$ = $1;
    }
    | for_statement
    {
        $$ = $1;
    }
    | do_while_statement
    {
        $$ = $1;
    }
    | return_statement
    {
        $$ = $1;
    }
    | function_call SEMICOLON
    {
        $$ = $1;
    }
    | LBRACE statement_list RBRACE
    {
        $$ = create_node("BLOCK", $2, NULL, NULL, NULL);
    }
    ;

assignment:
    IDENTIFIER ASSIGN expression SEMICOLON
    {
        $$ = create_node("ASSIGN", $3, NULL, NULL, $1);
    }
    | LBRACKET IDENTIFIER RBRACKET ASSIGN expression SEMICOLON
    {
        $$ = create_node("ASSIGN_ARRAY", $5, NULL, NULL, $2);
    }
    | MULTIPLY IDENTIFIER ASSIGN expression SEMICOLON
    {
        $$ = create_node("ASSIGN_PTR", $4, NULL, NULL, $2);
    }
    ;

if_statement:
    IF LPAREN expression RPAREN statement
    {
        $$ = create_node("IF", $3, $5, NULL, NULL);
    }
    | IF LPAREN expression RPAREN statement ELSE statement
    {
        $$ = create_node("IF_ELSE", $3, $5, $7, NULL);
    }
    ;

while_statement:
    WHILE LPAREN expression RPAREN statement
    {
        $$ = create_node("WHILE", $3, $5, NULL, NULL);
    }
    ;

for_statement:
    FOR LPAREN assignment expression SEMICOLON assignment RPAREN statement
    {
        $$ = create_node("FOR", $3, $4, $6, NULL);
    }
    ;

do_while_statement:
    DO statement WHILE LPAREN expression RPAREN SEMICOLON
    {
        $$ = create_node("DO_WHILE", $2, $5, NULL, NULL);
    }
    ;

return_statement:
    RETURN expression SEMICOLON
    {
        $$ = create_node("RETURN", $2, NULL, NULL, NULL);
    }
    ;

expression:
    expression PLUS term
    {
        $$ = create_node("EXPR", $1, $3, NULL, "+");
    }
    | expression MINUS term
    {
        $$ = create_node("EXPR", $1, $3, NULL, "-");
    }
    | term
    {
        $$ = $1;
    }
    ;

term:
    term MULTIPLY factor
    {
        $$ = create_node("TERM", $1, $3, NULL, "*");
    }
    | term DIVIDE factor
    {
        $$ = create_node("TERM", $1, $3, NULL, "/");
    }
    | factor
    {
        $$ = $1;
    }
    ;

factor:
    INT_LITERAL
    {
        char buffer[20];
        sprintf(buffer, "%d", $1);
        $$ = create_node("INT_LITERAL", NULL, NULL, NULL, strdup(buffer));
    }
    | FLOAT_LITERAL
    {
        char buffer[20];
        sprintf(buffer, "%f", $1);
        $$ = create_node("FLOAT_LITERAL
    {
        char buffer[20];
        sprintf(buffer, "%f", $1);
        $$ = create_node("FLOAT_LITERAL", NULL, NULL, NULL, strdup(buffer));
    }
    | DOUBLE_LITERAL
    {
        char buffer[20];
        sprintf(buffer, "%lf", $1);
        $$ = create_node("DOUBLE_LITERAL", NULL, NULL, NULL, strdup(buffer));
    }
    | CHAR_LITERAL
    {
        char buffer[2];
        buffer[0] = $1;
        buffer[1] = '\0';
        $$ = create_node("CHAR_LITERAL", NULL, NULL, NULL, strdup(buffer));
    }
    | BOOL_LITERAL
    {
        char buffer[6];
        sprintf(buffer, "%s", $1 ? "true" : "false");
        $$ = create_node("BOOL_LITERAL", NULL, NULL, NULL, strdup(buffer));
    }
    | IDENTIFIER
    {
        $$ = create_node("IDENTIFIER", NULL, NULL, NULL, $1);
    }
    | LPAREN expression RPAREN
    {
        $$ = $2;
    }
    ;

function_call:
    IDENTIFIER LPAREN argument_list RPAREN
    {
        $$ = create_node("FUNCTION_CALL", $3, NULL, NULL, $1);
    }
    ;

argument_list:
    /* empty */
    {
        $$ = NULL;
    }
    | argument_declaration_list
    {
        $$ = $1;
    }
    ;

argument_declaration_list:
    expression
    {
        $$ = create_node("ARG_LIST", $1, NULL, NULL, NULL);
    }
    | argument_declaration_list COMMA expression
    {
        $$ = create_node("ARG_LIST", $1, NULL, $3, NULL);
    }
    ;

%%

Node *create_node(char *type, Node *left, Node *right, Node *next, char *value) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->type = strdup(type);
    new_node->left = left;
    new_node->right = right;
    new_node->next = next;
    new_node->value = value ? strdup(value) : NULL;
    return new_node;
}

void print_ast(Node *node, int depth) {
    if (node == NULL) return;
    for (int i = 0; i < depth; i++) printf("  ");
    printf("(%s", node->type);
    if (node->value) printf(" %s", node->value);
    printf(")\n");
    print_ast(node->left, depth + 1);
    print_ast(node->right, depth + 1);
    print_ast(node->next, depth);
}

void free_ast(Node *node) {
    if (node == NULL) return;
    free(node->type);
    if (node->value) free(node->value);
    free_ast(node->left);
    free_ast(node->right);
    free_ast(node->next);
    free(node);
}

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

int main(void) {
    if (yyparse() == 0) {
        printf("Parse successful.\n");
        print_ast(ast_root, 0);
        free_ast(ast_root);
    } else {
        printf("Parse failed.\n");
    }
    return 0;
}




=============================


/*Scanner-file*/
%{
#include<stdio.h>
#include "y.tab.h"
%}
 /*%x comment*/

%%
  /*Types /*Keywords Lexemes*/
bool {return BOOL;}
char {return CHAR;}
int {return INT;}
real {return REAL;}
string {return STRING;}
int\* {return INTPTR;}
char\* {return CHARPTR;}
real\* {return REALPTR;}

  /*Statement -Loops*/
if {return IF;}
else {return ELSE;}
while {return WHILE;}
for {return FOR;}
var {return VARIABLE;}
func {return FUNCTION;}
proc {return PROCEDUR;}
null {return NULLL;}
Main {return MAIN;}
 
  /*Operators*/
"&&" {return AND;}
"/" {return DIVISION;}
"=" {return ASSINGMENT;}
"==" {return EQL;}
">" {return GREATER;}
">=" {return GREATEREQL;}
"<" {return LESS;}
"<=" {return LESSEQL;}
"-" {return MINUS;}
"!" {return NOT;}
"!=" {return NOTEQL;}
"||" {return OR;}
"+" {return PLUS;}
"*" {return MULTI;}
"&" {return ADDRESS;}
"^" {return DEREFRENCE;}

  /*Other Lexemes*/
"|" {return LENGTH;}
";" {return SEMICOLON;}
":" {return COLON;}
"," {return COMMA;}
"{" {return OPENBRACE;}
"}" {return CLOSEBRACE;}
"(" {return OPENPAREN;}
")" {return CLOSEPAREN;}
"[" {return OPENBRACKET;}
"]" {return CLOSEBRACKET;}
 
 "/""%".*"%""/" {return COMMENT;}

  /*Literl*/
return {return RETURN;}
true {return BOOLTRUE;}
false {return BOOLFALSE;}
[a-zA-Z][a-zA-Z0-9_]* { yylval.string= strdup(yytext);return IDENTIFIER;}
"\""[^"]*"\"" {yylval.string= strdup(yytext);return STRING_LTL;}
\'.\' {yylval.string= strdup(yytext);return CHAR_LTL;}
[+-]?[1-9][0-9]*|[0-9] {yylval.string= strdup(yytext);return DECIMAL_LTL;}
0(x|X)[0-9A-F]+ {yylval.string= strdup(yytext);return HEX_LTL;}
[-+]?[0-9]*\.?[0-9]*[eE]?[-+]?[0-9]+ {yylval.string= strdup(yytext);return REAL_LTL;}
	/*Skip Whitespace, Enter, Tab*/
[\n] {yylineno++;} //For each line (enter=\n), do yylineo+=1
[ \t]+ ;
. return yytext[0];
%%

